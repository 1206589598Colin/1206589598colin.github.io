# 查询DSL

## 查询过滤的区别

Elasticsearch提供了基于JSON的完整查询DSL来定义查询。查询DSL包括两种子句：

* 叶查询子句 ：在特定的字段上查找特定的值，比如match、term或者range查询。这些查询可以自己使用。

* 复合查询子句 ：包含其他叶查询或复合查询子句，以合理的方式结合多条查询（比如bool或dis_max查询），或者改变查询行为（比如not或constant_score查询）。

* 查询 （query）用于检查内容与条件是否匹配，并且计算_score元字段表示匹配度。查询的结构中以query参数开始来执行内容查询。

* 过滤 （filter）不计算匹配得分，只是简单地决定文档是否匹配。内容过滤主要用于过滤结构化的数据，例如：时间段是否在2015到2016年之间，status字段是否设置为"published"。

使用过滤往往会被Elasticsearch自动缓存来提高性能。

查询的子句也可以传递filter参数，比如bool查询内的filter、constant_score查询内的filter参数等。

举个查询子句的例子。查询会匹配符合下列所有条件的文档：

* title字段包含单词Search。

* content字段包含单词Elasticsearch。

* status字段包含准确的单词published。

* publish_date字段包含从2015年1月1日之后的日期。

请求：POST <http://127.0.0.1:9200/secisland/_search>

``` 
{
  "query": {
    "bool": {
      "must": [
        { "match": { "title":"Search"}},
        { "match": { "content": "Elasticsearch" }}
      ],
      "filter": [
        { "term":  { "status": "published" }},
        { "range": { "publish_date": { "gte": "2015-01-01" }}}
      ]
    }
  }
}
```

query参数表示内容查询。内容查询中使用的bool和match子句，用于计算每个文档的匹配得分。

filter参数表示内容过滤。内容过滤中使用的term和range子句，会过滤掉不匹配的文档，并且不影响计算文档匹配得分。

最简单的查询，匹配所有文档，文档的_score值是1.0。

``` 
{ "match_all": {} }
```

可以使用boost参数修改_score值：

``` 
{ "match_all": { "boost" : 1.2 }}
```

## 全文搜索

在文本字段上执行全文搜索。在执行查询之前，要了解被查询字段的分词方式，在查询字符串上应用每个被查询字段的映射分词器（或搜索分词器）。

标准查询 接受文本/数字/日期的查询，分析参数并组成查询条件。例如：

``` 
{
  "match" : {"message" : "this is a test"}
}
```

注意，message是字段名，可以用任何字段的名（包括_all）来替换。

有三种类型的match查询：布尔（boolean）、短语（phrase）和短语前缀（phrase_prefix）。除此之外还有多段查询、Lucene语法查询、简化查询。下面分别介绍。

1. 布尔查询

默认的标准查询类型，分析文本并且组成一个布尔查询。operator参数可以设置为or或者and来控制布尔子句（默认为or）。用于匹配的should子句（可选）的最小数量可以使用minimun_should_match参数来设置。

可以设置analyzer来控制在文本上执行分析过程的分词器。默认是字段映射中明确定义或者默认的搜索分词器。

lenient参数可以设置为true来忽略数据类型匹配出错造成的异常，例如尝试通过文本查询字符串来查询数字类型字段。默认为false。

（1）模糊匹配

fuzziness可以对请求的字段类型进行模糊匹配。

prefix_length 和 max_expansions 在这种情况下可以用来控制模糊过程。如果设置模糊选项，查询会使用 top_terms_blended_freqs_${max_expansions}作为重写方法。fuzzy_rewrite 参数可以控制查询会怎样进行重写。

提供额外参数的例子：

```
{
  "match" : {
    "message" : {"query" : "this is a test","operator" : "and"}
  }
}
```

（2）零索引词查询

如果查询使用的分词器移除所有词元，默认行为是不匹配任何文档。可以使用zero_terms_query选项进行修改，接受none（默认）和all（相当于match_all查询）。

``` 
{
  "match" : {
    "message" : {
      "query" : "to be or not to be",
      "operator" : "and",
      "zero_terms_query": "all"
    }
  }
}
```

2. 短语查询

短语查询分析文本并且创建短语查询。例如：

``` 
{
  "match_phrase" : {
    "message" : "this is a test"
  }
}
```

因为短语查询只是标准查询的一个类型，所以也可以用下面的方式使用：

``` 
{
  "match" : {
    "message" : {"query" : "this is a test","type" : "phrase"}
  }
}
```

短语查询根据一个可配置的slop（默认为0）匹配索引词。

可以设置analyzer来控制将要在文本上执行分词的分词器。默认是字段映射中定义的分析器，或者是默认的搜索分析器，例如：

``` 
{
  "match_phrase" : {
    "message" : {"query" : "this is a test","analyzer" : "my_analyzer"}
  }
}
```

3. 短语前缀查询

可以对文本最后一个字段进行前缀匹配。例如：

``` 
{
  "match_phrase_prefix" : {"message" : "this is a test"}
}
```

和短语查询一样，也可以用下面的方式：

``` 
{
  "match" : {
    "message" : {"query" : "this is a test","type" : "phrase_prefix"}
  }
}
```

接受短语查询相同的参数。此外，也接受max_expansions参数，可以控制最后索引词会扩展多少前缀。推荐设置为一个可以接受的值来控制查询的执行时间。例如：

``` 
{
  "match_phrase_prefix" : {
    "message" : {"query" : "this is a test","max_expansions" : 10}
  }
}
```

4. 多字段查询

在标准查询的基础上，支持多字段查询：

``` 
{
  "multi_match" : {
    "query": "this is a test",
    "fields": [ "subject", "message" ]
  }
}
```

字段可以通过通配符指定：

``` 
{
  "multi_match" : {
    "query": "Will Smith",
    "fields": [ "title", "*_name" ]
  }
}
```

个别字段可以用caret（^）符号加权：

``` 
{
  "multi_match" : {
    "query" : "this is a test",
    "fields" : [ "subject^3", "message" ]
  }
}
```

上述代码的含义是：subject字段比message字段重要三倍。

多匹配查询内部执行方式取决于type参数，可以设置的值如下所示：

* best_fields------（默认）查找匹配任何字段的文档，但是使用最佳匹配字段的_score。

* most_fields------查找匹配任何字段的文档，结合每个字段的_score。

* cross_fields------用相同的分析器处理字段，把这些字段当作一个大字段。查找任何字段的每个单词。

* phrase------在每个字段上运行短语匹配查询，结合每个字段的_score。

* phrase_prefix------在每个字段上运行短语前缀匹配查询，结合每个字段的_score。

下面介绍这几个值。

（1）best_fields

在同一个字段中搜索多个单词的时候此参数最有用。例如，一个字段中包含"brown fox"比包含"brown"或包含"fox"更有意义。best_fields类型对每个字段生成一个匹配查询并且封装成dis_max查询，来找到最佳匹配字段。例如，查询语句：

``` 
{
  "multi_match" : {
    "query": "brown fox",
    "type": "best_fields",
    "fields": [ "subject", "message" ],
    "tie_breaker": 0.3
  }
}
```

会执行为：

``` 
{
  "dis_max": {
    "queries": [
      { "match": { "subject": "brown fox" }},
      { "match": { "message": "brown fox" }}
    ],
    "tie_breaker": 0.3
  }
}
```

通常，best_fields类型使用最佳匹配字段的得分，但是如果指定了tie_breaker，可以通过"最佳匹配字段的得分"来计算匹配得分。

所有其他匹配字段的参数包括tie_breaker*_score相加。同时，接受analyzer、boost、operator、minimum_should_match、fuzziness、prefix_length、max_expansions、rewrite、zero_terms_query和cutoff_frequency。

其中，minimum_should_match参数可能的值见表4-2。

（2）most_fields

当查询多字段包含相同文本以不同方式分词的时候此参数最有用。例如，主字段包含同义词、词根和不区分大小写的索引词；第二个字段可能包含原始的索引词；第三个字段可以包含单个索引词。通过结合所有三个字段的得分可以通过主字段匹配尽可能多的文档，通过第二个和第三个字段把最相近的结果推到列表的顶端。

表4-2　最低匹配值

![](http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00043.jpg)

查询语句：

``` 
{
  "multi_match" : {
    "query": "quick brown fox",
    "type": "most_fields",
    "fields": [ "title", "title.original", "title.shingles" ]
  }
}
```

会执行为：

``` 
{
  "bool": {
    "should": [
      { "match": { "title": "quick brown fox" }},
      { "match": { "title.original": "quick brown fox" }},
      { "match": { "title.shingles": "quick brown fox" }}
    ]
  }
}
```

最终的匹配得分是将每个匹配子句的得分加在一块，然后除以匹配子句的数量。

接受的参数有：analyzer、boost、operator、minimun_should_match、fuzziness、prefix_length、max_expansions、rewrite、zero_terms_query和cutoff_frequency。

（3）cross_fields

当结构化的文档中多个字段应该匹配的时候，此参数特别有用。例如，当通过first_name和last_name字段查询"Will Smith"的时候，最佳的匹配是"Will"在一个字段，"Smith"在另一个字段。

一种处理这种查询的简单方式是将first_name和last_name字段索引到一个full_name字段。当然，这只能在索引的时候完成。

cross_fields类型在查询时通过采取term-centric方法来尝试解决这个问题。首先将查询字符串分词为单独的索引词，然后在任一字段中查找每个索引词。

查询示例如下：

``` 
{
  "multi_match" : {
    "query": "Will Smith",
    "type": "cross_fields",
    "fields": [ "first_name", "last_name" ],
    "operator": "and"
  }
}
```

接受的参数有：analyzer、boost、operator、minimum_should_match、zero_terms_query和cutoff_frequency。

（4）phrase和phrase_prefix

短语和短语前缀类型和best_fields一样，只不过使用的是match_phrase查询或者match_phrase_prefix查询而不是match查询。

查询示例如下：

``` 
{
  "multi_match" : {
    "query": "quick brown f",
    "type": "phrase_prefix",
    "fields": [ "subject", "message" ]
  }
}
```

会执行为：

``` 
{
  "dis_max": {
    "queries": [
      { "match_phrase_prefix": { "subject": "quick brown f" }},
      { "match_phrase_prefix": { "message": "quick brown f" }}
    ]
  }
}
```

接受如下参数：analyzer、boost、slop和zero_terms_query参数。此外，短语前缀类型接受max_expansions。

（5）cross_field和分词器

cross_field类型只能够工作在使用相同分词器的term-centric模式的字段。具有相同分词器的字段被分在一组，如果有多个分组，会通过bool查询结合在一起。

例如，first和last字段拥有相同的分词器，添加first.edge和last.edge使用edge_ngram分析器，查询：

``` 
{
  "multi_match" : {
    "query": "Jon",
    "type": "cross_fields",
    "fields": ["first", "first.edge","last",  "last.edge"]
  }
}
```

first和last会被组在一起作为单独的字段，first.edge和last.edge会被组在一起作为单独的字段。

可以重写查询作为两个通过bool查询联合在一起的cross_fields查询，然后对其中一个应用minimum_should_match参数：

``` 
{
  "bool": {
    "should": [
      {
        "multi_match" : {
          "query": "Will Smith",
          "type": "cross_fields",
          "fields": [ "first", "last" ],
          "minimum_should_match": "50%"
        }
      },
    {
        "multi_match" : {
          "query": "Will Smith",
          "type": "cross_fields",
          "fields": [ "*.edge" ]
        }
      }
    ]
  }
}
```

也可以强迫所有字段到相同的分组，方法是在查询中指定analyzer参数：

``` 
{
  "multi_match" : {
    "query": "Jon",
    "type": "cross_fields",
    "analyzer": "standard",
    "fields": [ "first", "last", "*.edge" ]
  }
}
```

5. Lucene语法查询

通过使用语法分析器来分析内容进行查询：

``` 
{
  "query_string" : {
    "default_field" : "content",
    "query" : "this AND that OR thus"
  }
}
```

query_string为最高级别，参数见表4-3。

表4-3　查询字符串参数

![](http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00044.jpg)

（1）默认字段

如果在查询字符串语法中没有明确指出查询的字段，会inde.query.default_field提取需要搜索的字段。默认为_all字段。

所以，如果_all字段被禁用，将其修改设置为一个不同的默认字段是很有必要的。

（2）多字段

query_string查询也可以在多个字段上执行。可以通过"fields"参数定义字段。

多字段执行query_string查询的意义在于利用OR子句扩展每个查询索引词，形如：

``` 
field1:query_term OR field2:query_term | ...

```

例如，下面的查询：

``` 
{
  "query_string" : {"fields" : ["content", "name"],"query" : "this AND that"}
}
```

实际匹配形式：

``` 
{
  "query_string": {
  "query": "(content:this OR name:this) AND (content:that OR name:that)"}
}
```

（3）语法

查询字符串被解析为一系列字段和运算符。字段可以是一个单词或者短语（搜索短语中的所有单词，以相同的顺序用双引号包起来）。

可用的选项有：

1）字段名------可以指定default_field之外的其他字段。

* status字段包含active。

``` 
status:active

```

* title字段包含quick或brown。

``` 
title:(quick OR brown)
title:(quick brown)

```

* author字段包含短语"John Smith"。

``` 
author:"John Smith"

```

* 任何book.title、book.content或book.date字段包含quick或brown（注意，需要用反斜线转义*）。

``` 
book.\*:(quick brown)

```

* title字段不包含（或者缺失）值。

``` 
_missing_:title

```

* title字段包含任何非空值。

``` 
_exists_:title

```

2）通配符------通配符搜索使用? 代替单个字符，使用*代替零个或多个字符。

``` 
qu?ck bro*

```

3）正则表达式------通过使用斜线（/）包围，正则表达式可以植入到查询字符串中。

``` 
name:/joh?n(ath[oa]n)/

```

4）模糊化。

``` 
quikc~1

```

5）邻近搜索------可以指定短语中单词的最大编辑距离。

``` 
"fox quick"~5

```

字段中的文本越接近于查询字符串的顺序，文档的相关性越高。短语"quick fox"的相关性高于"quick brown fox"。

6）范围------可以指定日期、数字或字符串字段的范围。包含的范围用方括号指定[min TO max]，不包含的范围用花括号指定{min TO max}。

-2016年的所有日期

``` 
date:[2016-01-01 TO 2016-12-31]

```

-数字1到5

``` 
count:[1 TO 5]

```

-alpha和omega之间的标签，不包括alpha和omega

``` 
tag:{alpha TO omega}
```

-大于等于10的数

``` 
count:[10 TO *]

```

-2016年之前的日期

``` 
date:{* TO 2016-01-01}
```

-大于等于1小于5的数

``` 
count:[1 TO 5}
```

-一边值为无限

``` 
age:>10
age:>=10
age:<10
age:<=10

```

7）增权。

``` 
quick^2 fox
"john smith"^2
(foo bar)^4

```

8）布尔操作符。

+必须包含。

-必须不包含。

支持AND、OR和NOT（也可以写作&&、||和!）操作符。

``` 
((quick AND fox) OR (brown AND fox) OR fox) AND NOT news

```

等同于：

``` 
{
  "bool": {
    "must": { "match": "fox"},
    "should": { "match": "quick brown" },
    "must_not": { "match": "news"}
  }
}
```

9）分组------多字段或子句可以使用圆括号进行分组。

``` 
status:(active OR pending) title:(full text search)^2

```

10）保留字符------查询中出现保留字符的时候，需要进行转义。

``` 
\(1\+1\)\=2

```

保留字符有：+-=&&||><!(){}[]^"~*?:\/

11）空查询------如果查询字符串是空的或者仅包含空格，查询会生成一个空结果集。

6. 简化查询

系统提供了简化语法来进行查询。不像普通的Lucene语法查询，简化查询不会抛出异常，而且会丢弃查询无效部分：

``` 
{
  "simple_query_string" : {
    "query": "\"fried eggs\" +(eggplant | potato) -frittata",
    "analyzer": "snowball",
    "fields": ["body^5","_all"],
    "default_operator": "and"
  }
}
```

简化查询可以接受参数见表4-4。

表4-4　简化查询参数

![](http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00045.jpg)

（1）语法

简单查询字符串支持的特殊字符如下所示：

+　表示AND运算符。

|　表示OR运算符。

--　排除一个词元。

"　包含一批词元来指定搜索短语。

*　在索引词结尾表示前缀查询。

（和）　表示优先。

~N　在单词的后面，表示编辑距离（模糊性）。

~N　在短语的后面，表示溢出量。

为了搜索任何这些特殊字符，需要使用斜线（\）。

（2）默认字段

当在搜索字符串语法中没有明确指出需要搜索的字段时，index.query.default_field会用来提取要搜索的字段。默认为_all字段。

（3）多字段

字段参数也可以包括基于模式的字段名，可以自动扩展相关字段（动态引入包含的字段）。例如：

``` 
{
  "simple_query_string" : {"fields" : ["content", "name.*^5"],
  "query" : "foo bar baz"}
}
```

（4）标记

简单查询字符串支持多个标记来指定需要启用的解析功能。在flags参数中指定为一个用|分隔的字符串：

``` 
{
  "simple_query_string" : {"query" : "foo | bar + baz*",
    "flags" : "OR|AND|PREFIX"}
}
```

可用的标记有：ALL、NONE、AND、OR、NOT、PREFIX、PHRASE、PRECEDENCE、ESCAPE、WHITESPACE、FUZZY、NEAR和SLOP。
