# 动态模版

动态模板允许您更好地控制 Elasticsearch 如何将数据映射到默认的动态字段映射规则之外。您可以通过将动态参数设置为 true 或运行时来启用动态映射。然后你可以使用动态模板定义自定义的映射，这些映射可以根据匹配条件应用到动态添加的字段:

- 操作 Elasticsearch 检测到的数据类型
- 使用模式来匹配字段名
- 按照完整的虚线路径进行操作

使用映射规范中的{name}和{dynamic_type}模板变量作为占位符。

动态字段映射只有在字段包含具体值时才会添加ー而不是null或空数组。如果在动态模板中使用 null_value 选项，则只有在第一个具有字段具体值的文档被索引之后，才会应用它。

动态模板被指定为命名对象的数组:

```
 "dynamic_templates": [
    {
      "my_template_name": { 
        ...  match conditions ... 
        "mapping": { ... } 
      }
    },
    ...
  ]
```

* 模板名称可以是任何字符串值。
* 匹配条件可以包括: match_mapping_type、 match、 match_pattern、 unmatch、 path_match、 path_unmatch。
* 匹配字段应该使用的映射。

## 验证动态模板

如果提供的映射包含无效映射代码片段，则返回验证错误。在索引时应用动态模板时进行验证，在大多数情况下，在更新动态模板时进行验证。在某些情况下，提供无效的映射代码片段可能会导致动态模板的更新或验证失败:

- 如果没有 但该模板对于至少一个预定义的映射类型有效，则映射代码片段被认为是有效的。但是，如果与模板匹配的字段被索引为不同的类型，则在索引时返回验证错误。例如，将动态模板配置为 被认为作为字符串类型有效，但是如果匹配动态模板的字段被索引为 long，则在索引时返回验证错误。建议配置 或配置所需的 JSON 类型 在地图片段中
- 如果 占位符用于映射代码片段，在更新动态模板时跳过验证。这是因为当时字段名称未知。相反，在索引时应用模板时进行验证

模板是按顺序处理的ーー第一个匹配的模板胜出。当通过 put 映射 API 放置新的动态模板时，所有现有的模板都会被覆盖。这允许在最初添加动态模板之后对其进行重新排序或删除。

## 映射动态模板中的运行时字段

如果希望 Elasticsearch 动态地将特定类型的新字段映射为运行时字段，请在索引映射中设置"dynamic":"runtime"。这些字段没有索引，并且在查询时从 _source 加载。

或者，您可以使用默认的动态映射规则，然后创建动态模板来将特定字段映射为运行时字段。在索引映射中设置"dynamic": "true"，然后创建一个动态模板，将特定类型的新字段映射为运行时字段。

假设您有每个字段都以 ip_开头的数据。根据动态映射规则，Elasticsearch 将任何通过数值检测的字符串映射为 float 或 long。但是，您可以创建一个动态模板，将新字符串映射为类型为 ip 的运行时字段。

下面的请求定义了一个名为 strings_as_ip 的动态模板。当 Elasticsearch 检测到与 ip * 模式匹配的新字符串字段时，它会将这些字段映射为类型为 ip 的运行时字段。因为 ip 字段不是动态映射的，所以您可以使用这个模板"dynamic": "true" 或 "dynamic": "runtime"。

```
PUT my-index-000001/
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_ip": {
          "match_mapping_type": "string",
          "match": "ip*",
          "runtime": {
            "type": "ip"
          }
        }
      }
    ]
  }
}
```

有关如何使用动态模板将字符串字段映射为索引字段或运行时字段，请参见此示例。

match_mapping_type 是 JSON 解析器检测到的数据类型。因为 JSON 不区分 long 和整数，也不区分 double 和 float，所以它总是选择更广泛的数据类型，比如 long 表示整数，double 表示浮点数。

自动检测以下数据类型:

| **JSON data type** | **`"dynamic":"true"`** | **`"dynamic":"runtime"`** |
| :-- |  :-- |  :-- |
| `null` | No field added | No field added |
| `true` or `false` | `boolean` | `boolean` |
| `double` | `float` | `double` |
| `integer` | `long` | `long` |
| `object`^1^ | `object` | `object` |
| `array` | Depends on the first non-`null` value in the array | Depends on the first non-`null` value in the array |
| 通过日期检测的string | `date` | `date` |
| 通过数字检测的string | `float` or `long` | `double` or `long` |
| 不能通过日期检测或数字检测的字符串 | 带有. keyword 子字段的 text | `keyword` |

使用通配符(*)匹配所有数据类型。

例如，如果我们想将所有整数字段映射为整数字段而不是长字段，并将所有字符串字段映射为文本和关键字，我们可以使用以下模板:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "integers": {
          "match_mapping_type": "long",
          "mapping": {
            "type": "integer"
          }
        }
      },
      {
        "strings": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "text",
            "fields": {
              "raw": {
                "type":  "keyword",
                "ignore_above": 256
              }
            }
          }
        }
      }
    ]
  }
}

PUT my-index-000001/_doc/1
{
  "my_integer": 5, 
  "my_string": "Some string" 
}
```

* my_integer 字段被映射为整数。
* my_string 字段被映射为一个文本，带有一个关键字 multi 字段。

## match 和 unmatch

match 参数使用一个模式来匹配字段名，而 unmatch 使用一个模式来排除匹配的字段。

match_pattern 参数调整 match 参数的行为，以支持字段名称上的完整 Java 正则表达式匹配，而不是简单的通配符。例如:

```
  "match_pattern": "regex",
  "match": "^profit_\d+$"
```

下面的示例匹配所有名称以 long_ (除了以 _text 结尾的字段)开头的字符串字段，并将它们映射为长字段:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "longs_as_strings": {
          "match_mapping_type": "string",
          "match":   "long_*",
          "unmatch": "*_text",
          "mapping": {
            "type": "long"
          }
        }
      }
    ]
  }
}

PUT my-index-000001/_doc/1
{
  "long_num": "5", 
  "long_text": "foo" 
}
```

* long_num 字段被映射为 long。
* long_text 字段使用默认的字符串映射。

path_match 和 path_unmatch 参数的工作方式与 match 和 unmatch 相同，但是操作的是字段的完整虚线路径，而不仅仅是最终名称，例如某个_object。*.某个地方。

此示例将 name 对象中任何字段的值复制到顶级 full_name 字段，但中间字段除外:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "full_name": {
          "path_match":   "name.*",
          "path_unmatch": "*.middle",
          "mapping": {
            "type":       "text",
            "copy_to":    "full_name"
          }
        }
      }
    ]
  }
}

PUT my-index-000001/_doc/1
{
  "name": {
    "first":  "John",
    "middle": "Winston",
    "last":   "Lennon"
  }
}
```

请注意，path_match 和 path_unmatch 参数除了与叶字段相匹配外，还与对象路径相匹配。例如，为下面的文档建立索引会导致一个错误，因为 path_match 设置也匹配对象字段 name.title，它不能被映射为文本:

```
PUT my-index-000001/_doc/2
{
  "name": {
    "first":  "Paul",
    "last":   "McCartney",
    "title": {
      "value": "Sir",
      "category": "order of chivalry"
    }
  }
}
```

## 模板变量

在与字段名称和检测到的动态类型的映射中替换{ name }和{ dynamic_type }占位符。下面的示例设置所有字符串字段，使用与字段同名的分析器，并禁用所有非字符串字段的 doc_value:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "named_analyzers": {
          "match_mapping_type": "string",
          "match": "*",
          "mapping": {
            "type": "text",
            "analyzer": "{name}"
          }
        }
      },
      {
        "no_doc_values": {
          "match_mapping_type":"*",
          "mapping": {
            "type": "{dynamic_type}",
            "doc_values": false
          }
        }
      }
    ]
  }
}

PUT my-index-000001/_doc/1
{
  "english": "Some English text", 
  "count":   5 
}
```

* 英文字段被映射为带有英文分析器的字符串字段。
* count 字段映射为禁用 doc_值的长字段。

## 动态模板示例

下面是一些可能有用的动态模板的例子:

### 结构化搜索

当您设置" dynamic": "true"时，Elasticsearch 将把字符串字段映射为带有关键字子字段的文本字段。如果你只是索引结构化内容或者对全文搜索不感兴趣，你可以使 Elasticsearch 只把你的字段作为关键字字段。但是，必须搜索与索引搜索这些字段完全相同的值。

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_keywords": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "keyword"
          }
        }
      }
    ]
  }
}
```

### text-只有字符串的映射

与前面的例子相反，如果你只关心字符串字段的全文搜索，而不打算运行聚合、排序或精确搜索，你可以告诉 Elasticsearch 将字符串映射为文本:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_text": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "text"
          }
        }
      }
    ]
  }
}
```

或者，您可以创建一个动态模板，将字符串字段映射为映射的运行时部分中的关键字字段。当 Elasticsearch 检测到类型为 string 的新字段时，这些字段将被创建为类型为 keyword 的运行时字段。

虽然字符串字段不会被索引，但是它们的值存储在_source 中，可以用于搜索请求、聚合、筛选和排序。

例如，下面的请求创建一个动态模板，将字符串字段映射为 keyword 类型的运行时字段。虽然运行时定义是空白的，新的字符串字段将被映射为基于 Elasticsearch 用于向映射添加字段类型的动态映射规则的关键字运行时字段。任何没有通过日期检测或数字检测的字符串都会自动映射为关键字:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_keywords": {
          "match_mapping_type": "string",
          "runtime": {}
        }
      }
    ]
  }
}
```

你索引一个简单的文档:

```
PUT my-index-000001/_doc/1
{
  "english": "Some English text",
  "count":   5
}
```

当你查看映射时，你会看到英文字段是一个类型为 keyword 的运行时字段:

```
GET  my-index-000001/_mapping
```
```
{
  "my-index-000001" : {
    "mappings" : {
      "dynamic_templates" : [
        {
          "strings_as_keywords" : {
            "match_mapping_type" : "string",
            "runtime" : { }
          }
        }
      ],
      "runtime" : {
        "english" : {
          "type" : "keyword"
        }
      },
      "properties" : {
        "count" : {
          "type" : "long"
        }
      }
    }
  }
}
```

### 禁用标准

常模为指数时间评分因子。如果您不关心计分，例如，如果您从来不按分数对文档进行排序，那么您可以禁用索引中这些计分因子的存储并节省一些空间。

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_keywords": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "text",
            "norms": false,
            "fields": {
              "keyword": {
                "type": "keyword",
                "ignore_above": 256
              }
            }
          }
        }
      }
    ]
  }
}
```

子关键字字段在此模板中显示为与动态映射的默认规则一致。当然，如果您不需要它们，因为您不需要对这个字段执行精确的搜索或聚合，那么您可以按照前面部分的描述移除它。

### 时间序列

在使用 Elasticsearch 进行时间序列分析时，通常会有许多数字字段，您经常会对这些字段进行聚合，但是不会对其进行过滤。在这种情况下，你可以禁用这些字段的索引，以节省磁盘空间，也许还可以获得一些索引速度:

```
PUT my-index-000001
{
  "mappings": {
    "dynamic_templates": [
      {
        "unindexed_longs": {
          "match_mapping_type": "long",
          "mapping": {
            "type": "long",
            "index": false
          }
        }
      },
      {
        "unindexed_doubles": {
          "match_mapping_type": "double",
          "mapping": {
            "type": "float", 
            "index": false
          }
        }
      }
    ]
  }
}
```
* 与默认的动态映射规则一样，双精度打印被映射为浮点数，这通常足够精确，但需要一半的磁盘空间。